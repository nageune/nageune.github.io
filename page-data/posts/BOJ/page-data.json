{"componentChunkName":"component---src-templates-posts-template-index-tsx","path":"/posts/BOJ","result":{"pageContext":{"currentCategory":"BOJ","categories":["All","BOJ","Experience","대회","독서","자격증","회고"],"edges":[{"node":{"id":"872d498b-cf31-5a87-82aa-93906df5fa50","excerpt":"📝 문제 문제 링크\n 📖 설명 사과가 남지 않으면서 사과를 받는 선수는 모두 같은 수의 사과를 받아야한다. 빨간 사과와 초록 사과의 최대공약수를 구하고 최대공약수의 약수를 구하면 위 조건을 만족하는 선수의 수를 모두 구할 수 있다. 빨간 사과와 초록 사과의 수를 선수의 수로 나눈 값을 출력한다. 최대공약수는 유클리드 호제법을 사용해 구한다. 약수를 구하는 방법은 구하는 수의 제곱근까지 약수를 찾고 찾은 값으로 구하는 수를 나눈 값도 약수임을 이용해 시간을 줄인다.\n ⌨️ 코드 📝 문제 📖 설명 ⌨️ 코드","fields":{"slug":"/BOJ-2942/"},"frontmatter":{"categories":"BOJ","title":"BOJ 2942 퍼거슨과 사과","date":"2024. 9. 17."}},"next":{"fields":{"slug":"/BOJ-23835/"}},"previous":null,"categoriesMap":{"BOJ":true}},{"node":{"id":"e9c78bb8-390a-5299-904c-02d49729a912","excerpt":"📝 문제 문제 링크\n 📖 설명 임의의 두 방 사이의 경로는 정확히 한 개 있으므로 트리임을 알 수 있다. 1번 쿼리가 실행되면 DFS를 통해 경로를 탐색하고 2번 쿼리가 실행되면 저장한 배열을 통해 값을 조회만 한다. 양방향(무방향) 간선을 입력받아 저장하고 1번 쿼리인 경우 DFS를 실시한다. DFS는 몇 번째 배달하는 방인지를 나타내는 , 목적지 , 현재 위치 가 있다. 탐색하며 가는 모든 경로에  만큼의 우유를 배달하고, 경로를 돌아가는 경우 다시 제거한다. 만약 인 경우 1을 하여 경로 상 배달했던 우유를 제거하지 않도록 한다. 2번 쿼리인 경우 배달한 우유를 저장한  배열의 값을 조회하여 출력한다.\n ⌨️ 코드 📝 문제 📖 설명 ⌨️ 코드","fields":{"slug":"/BOJ-23835/"},"frontmatter":{"categories":"BOJ","title":"BOJ 23835 어떤 우유의 배달목록 (Easy)","date":"2024. 9. 15."}},"next":{"fields":{"slug":"/BOJ-5376/"}},"previous":{"fields":{"slug":"/BOJ-2942/"}},"categoriesMap":{"BOJ":true}},{"node":{"id":"eb02303d-7b83-53ac-a865-0296288b7b7b","excerpt":"📝 문제 문제 링크\n 📖 설명 소수를 분수로 변환하는 것은 중학교 수학 과정이다.\n 자세한 설명은 출처를 참고하자. 문제에서 라고 명시되어 있으므로 그림 중 아래 방식을 따라 구현하고 이라고 생각하면 된다. 분모와 분자를 구했다면 유클리드 호제법을 사용해 최대공약수를 구하고 약분한 후 출력 형식에 맞게 출력한다. 계산 과정에서 32비트 정수 범위를 넘어갈 수 있으므로 을 사용해야 한다.  ⌨️ 코드 📝 문제 📖 설명 ⌨️ 코드","fields":{"slug":"/BOJ-5376/"},"frontmatter":{"categories":"BOJ","title":"BOJ 5376 소수를 분수로","date":"2024. 9. 15."}},"next":{"fields":{"slug":"/BOJ-1083/"}},"previous":{"fields":{"slug":"/BOJ-23835/"}},"categoriesMap":{"BOJ":true}},{"node":{"id":"6249a05c-61e9-545b-9daa-79a00ff8759c","excerpt":"📝 문제 문제 링크\n 📖 설명 크기가 N인 배열 A에서 최대 S번 연속된 두 개의 원소를 교환하여 사전순으로 가장 뒷서는 배열을 출력하는 문제이다. 최대 S번 이웃한 원소를 교환할 수 있다는 것은 i번째 원소로부터 S만큼 떨어진 위치의 수는 끌어올 수 있다는 뜻이다. 이 말은 A[i]부터 A[i+S]까지의 원소 중 가장 큰 값을 A[i]의 위치로 이동시키고 뒤로 한 칸씩 밀어내는 것이다. 이때 소모된 회수만큼 S를 감소시키고 S가 남아있다면 i를 1만큼 증가시켜 다시 한 번 반복한다.\n ⌨️ 코드 📝 문제 📖 설명 ⌨️ 코드","fields":{"slug":"/BOJ-1083/"},"frontmatter":{"categories":"BOJ","title":"BOJ 1083 소트","date":"2024. 9. 14."}},"next":{"fields":{"slug":"/독서-이상한-집/"}},"previous":{"fields":{"slug":"/BOJ-5376/"}},"categoriesMap":{"BOJ":true}}]}},"staticQueryHashes":["1321405810","3649515864"]}